/**
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model. All data, including
 * tasks and subtasks, is stored in a hierarchical structure under a user's
 * unique ID (`/users/{userId}`). This ensures that users can only ever access
 * their own data tree, providing strong data isolation by default.
 *
 * Data Structure:
 * The data is organized hierarchically to reflect ownership:
 * - /users/{userId}: Stores the user's profile document.
 * - /users/{userId}/lists/{listId}: Stores user-created task lists.
 * - /users/{userId}/tasks/{taskId}: Stores tasks owned by the user.
 *
 * Key Security Decisions:
 * - Strict Ownership: All read and write operations are restricted to the
 *   authenticated user whose UID matches the `{userId}` in the path.
 * - No Public Access: There are no publicly readable collections.
 * - User Enumeration Disabled: Listing the top-level `/users` collection
 *   is explicitly forbidden to prevent attackers from discovering user IDs.
 * - Self-Creation: A user can create their own profile document in `/users`
 *   but cannot create one for anyone else.
 *
 * Denormalization for Authorization:
 * This ruleset relies on path-based security. The user's UID is part of the
 * document path for all their associated data. This allows for extremely fast
 * and simple authorization checks (`request.auth.uid == userId`) without
 * needing to read any document data (i.e., no `get()` calls). For relational
 * integrity, key IDs (like `userId` and `taskId`) are also stored inside
 * documents to ensure data consistency upon creation and to prevent re-linking
 * on updates.
 *
 * Structural Segregation:
 * The structure strictly segregates each user's data into their own document
 * tree. This is the most secure and performant way to handle private user data,
 * as it makes unauthorized list queries impossible.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions for improved readability and reuse.
    
    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the currently authenticated user's ID matches the
     * provided userId from the path. This is the core of our
     * ownership-based security model.
     * @param userId The UID of the document owner from the path.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Ensures an operation is performed by the owner on an existing document.
     * Crucial for secure update and delete operations.
     * @param userId The UID of the document owner from the path.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * Validates that the User document's internal `id` field matches the
     * document's ID in the path upon creation.
     * @param userId The UID of the user from the path.
     */
    function hasValidUserDataOnCreate(userId) {
      return request.resource.data.id == userId;
    }

    /**
     * Enforces that the User document's internal `id` field is immutable.
     * It cannot be changed after the document is created.
     */
    function isUserDataImmutable() {
      return request.resource.data.id == resource.data.id;
    }

    /**
     * Validates that a new Task document's internal `userId` field matches
     * the user's ID in the path.
     * @param userId The UID of the user from the path.
     */
    function hasValidTaskDataOnCreate(userId) {
      return request.resource.data.userId == userId;
    }

    /**
     * Enforces that a Task document's `userId` is immutable, preventing
     * a task from being reassigned to a different owner.
     */
    function isTaskOwnerImmutable() {
      return request.resource.data.userId == resource.data.id;
    }
    
    /**
     * Validates that a new List document's internal `userId` field matches
     * the user's ID in the path.
     * @param userId The UID of the user from the path.
     */
    function hasValidListDataOnCreate(userId) {
      return request.resource.data.userId == userId;
    }

    /**
     * Enforces that a List document's `userId` is immutable, preventing
     * a list from being reassigned to a different owner.
     */
    function isListOwnerImmutable() {
      return request.resource.data.userId == resource.data.userId;
    }
    

    /**
     * @description
     *   Rules for the user profile documents. Each user has one document where
     *   the document ID is their Firebase Authentication UID.
     * @path /users/{userId}
     * @allow (create) An authenticated user creating their own profile document.
     *   e.g., `db.collection('users').doc('user_abc').set({ id: 'user_abc', ... })` by user 'user_abc'.
     * @deny (create) A user trying to create a profile for someone else.
     *   e.g., `db.collection('users').doc('user_xyz').set(...)` by user 'user_abc'.
     * @principle
     *   Enforces self-creation and ownership. Prevents user enumeration by
     *   disallowing list operations on the top-level collection.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false; // Prevent user enumeration
      allow create: if isOwner(userId) && hasValidUserDataOnCreate(userId);
      allow update: if isExistingOwner(userId) && isUserDataImmutable();
      allow delete: if isExistingOwner(userId);

      /**
       * @description
       *   Rules for the lists collection, which is nested under each user.
       *   Access is strictly limited to the owner of the parent user document.
       * @path /users/{userId}/lists/{listId}
       */
      match /lists/{listId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId) && hasValidListDataOnCreate(userId);
        allow update: if isExistingOwner(userId) && isListOwnerImmutable();
        allow delete: if isExistingOwner(userId);
      }


      /**
       * @description
       *   Rules for the tasks collection, which is nested under each user.
       *   Access is strictly limited to the owner of the parent user document.
       * @path /users/{userId}/tasks/{taskId}
       * @allow (list) A user listing their own tasks.
       *   e.g., `db.collection('users/user_abc/tasks').get()` by user 'user_abc'.
       * @deny (get) A user trying to read a task belonging to another user.
       *   e.g., `db.doc('users/user_xyz/tasks/task_123').get()` by user 'user_abc'.
       * @principle
       *   Restricts access to a user's own data tree through path-based security.
       */
      match /tasks/{taskId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId) && hasValidTaskDataOnCreate(userId);
        allow update: if isExistingOwner(userId) && isTaskOwnerImmutable();
        allow delete: if isExistingOwner(userId);
      }
    }
  }
}
